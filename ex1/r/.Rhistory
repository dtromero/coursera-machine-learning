linspace(-10, 10, 100)
seq(-10, 10, 100)
seq(-10, 10, length=100)
seq(-10, 10, length=100)
matrix(0,100,00)
matrix(0, nrow = 100, ncol = 100)
# Grid over which we will calculate J
theta0_vals <- seq(-10, 10, length=100);
theta1_vals <- seq(-1, 4, length=100);
# initialize J_vals to a matrix of 0's
J_vals <- matrix(0, nrow=length(theta0_vals), ncol=length(theta1_vals));
matrix(0, nrow = 100, ncol = 100)
J_vals
[theta0_vals[1], theta1_vals[1]]
(theta0_vals[1], theta1_vals[1]
(theta0_vals[1], theta1_vals[1])
(theta0_vals[1] theta1_vals[1])
(theta0_vals[1]; theta1_vals[1])
theta0_vals[1] theta1_vals[1]
theta0_vals[1]
theta0_vals[2]
theta0_vals[3]
theta0_vals[1]
c(theta0_vals[1], theta1_vals[1])
J_vals(1,2)
# initialize J_vals to a matrix of 0's
J_vals <- matrix(0, nrow=length(theta0_vals), ncol=length(theta1_vals));
J_vals(1,2)
J_vals(1,2)
J_vals <- matrix(0, nrow=length(theta0_vals), ncol=length(theta1_vals));
J_vals(1,2)
J_vals
J_vals(1)
J_vals[1]
J_vals[1,2]
# Fill out J_vals
for(i in 1:length(theta0_vals)) {
for (j in 1:length(theta1_vals)) {
t <- c(theta0_vals[i]; theta1_vals[j]);
J_vals[i,j] <- computeCost(X, y, t);
}
}
# Fill out J_vals
for(i in 1:length(theta0_vals)) {
for (j in 1:length(theta1_vals)) {
t <- c(theta0_vals[i], theta1_vals[j]);
J_vals[i,j] <- computeCost(X, y, t);
}
}
source('warmUpExercise.R')
source('plotData.R')
source('computeCost.R')
source('gradientDescent.R')
source('warmUpExercise.R')
source('plotData.R')
source('computeCost.R')
source('gradientDescent.R')
setwd('/home/dtromero/Documents/coursera-machine-learning/ex1/r/')
setwd('/home/dtromero/Documents/coursera-machine-learning/ex1/r/')
source('warmUpExercise.R')
source('plotData.R')
source('computeCost.R')
source('gradientDescent.R')
# Fill out J_vals
for(i in 1:length(theta0_vals)) {
for (j in 1:length(theta1_vals)) {
t <- c(theta0_vals[i], theta1_vals[j]);
J_vals[i,j] <- computeCost(X, y, t);
}
}
ex1
source('ex1.R')
source('ex1.R')
source('ex1.R')
J_vals
filled.contour(theta0_vals, theta1_vals)
filled.contour(theta0_vals, theta1_vals, J_vals)
filled.contour(theta0_vals, theta1_vals, J_vals, theta0_vals)
filled.contour(theta0_vals, theta1_vals, J_vals)
